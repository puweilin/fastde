# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fold Change
#' 
#' https://stackoverflow.com/questions/38338270/how-to-return-a-named-vecsxp-when-writing-r-extensions
#' 
#' @rdname ComputeFoldChange
#' @param matrix an expression matrix, COLUMN-MAJOR, each row is a sample, each column a sample
#' @param labels an integer vector, each element indicating the group to which a sample belongs.
#' @param calc_percents  a boolean to indicate whether to compute percents or not.
#' @param fc_name column name to use for the fold change results 
#' @param use_expm1 for "data", use expm1
#' @param min_threshold minimum threshold to count towards pct.1 and pct.2 percentages.
#' @param use_log for "data" and default log type, indicate log of the sum is to be used.
#' @param log_base base for the log
#' @param use_pseudocount for "data" and default log type, add pseudocount after log.
#' @param as_dataframe TRUE/FALSE.  TRUE = return a linearized dataframe.  FALSE = return matrices.
#' @param threads number of threads to use
#' @return array or dataframe
#' @name ComputeFoldChange
#' @export
ComputeFoldChange <- function(matrix, labels, calc_percents, fc_name, use_expm1, min_threshold, use_log, log_base, use_pseudocount, as_dataframe, threads) {
    .Call('_fastde_ComputeFoldChange', PACKAGE = 'fastde', matrix, labels, calc_percents, fc_name, use_expm1, min_threshold, use_log, log_base, use_pseudocount, as_dataframe, threads)
}

#' Filter based on FoldChange
#' 
#'  https://stackoverflow.com/questions/38338270/how-to-return-a-named-vecsxp-when-writing-r-extensions
#' 
#' @rdname FilterFoldChange
#' @param fc foldchange values, either as a vector or a matrix.  if matrix: 1 gene per col, 1 clust per row
#' @param pct1 percent greater than threshold (0) in class 1.
#' @param pct2 percent greater than threshold (0) in class 2.
#' @param init_mask  initial mask, based on an external "features" vector.
#' @param min_pct minimum threshold for max pct1, pct2
#' @param min_diff_pct minimum threshold for difference between max and min {pct1, pct2}
#' @param logfc_threshold if not scaled.data, then compare to the logfc.
#' @param only_pos keep only positive fc value, and not use abs when thresholding.
#' @param not_count  not scaled.data
#' @param threads number of threads to use
#' @return array of same shape as fc
#' @name FilterFoldChange
#' @export
FilterFoldChange <- function(fc, pct1, pct2, init_mask, min_pct, min_diff_pct, logfc_threshold, only_pos, not_count, threads) {
    .Call('_fastde_FilterFoldChange', PACKAGE = 'fastde', fc, pct1, pct2, init_mask, min_pct, min_diff_pct, logfc_threshold, only_pos, not_count, threads)
}

#' R Sparse Matrix Transpose
#'
#' This implementation directly constructs the new sparse matrix.  
#'     Output is also column-major, so there is random memory writes.
#' 
#' @rdname sp_transpose
#' @param sp_matrix a sparse matrix, of the form dgCMatrix
#' @return sp_matrix, transposed.
#' @name sp_transpose
#' @export
sp_transpose <- function(sp_matrix) {
    .Call('_fastde_sp_transpose', PACKAGE = 'fastde', sp_matrix)
}

#' Fast Wilcoxon-Mann-Whitney Test for dense matrix
#'
#' This implementation uses normal approximation, which works reasonably well if sample size is large (say N>=20)
#' 
#' @rdname wmwfast
#' @param matrix an expression matrix, COLUMN-MAJOR, each col is a feature, each row a sample
#' @param labels an integer vector, each element indicating the group to which a sample belongs.
#' @param rtype 
#' \itemize{
#' \item{0} : p(greater)
#' \item{1} : p(less)
#' \item{2} : p(twoSided)
#' \item{3} : U
#' }
#' @param continuity_correction TRUE/FALSE for continuity correction
#' @param as_dataframe TRUE/FALSE - TRUE returns a dataframe, FALSE returns a matrix
#' @param threads  number of concurrent threads.
#' @return array or dataframe.  for each gene/feature, the rows for the clusters are ordered by id.
#' @name wmwfast
#' @export
wmwfast <- function(matrix, labels, rtype, continuity_correction, as_dataframe, threads) {
    .Call('_fastde_wmwfast', PACKAGE = 'fastde', matrix, labels, rtype, continuity_correction, as_dataframe, threads)
}

